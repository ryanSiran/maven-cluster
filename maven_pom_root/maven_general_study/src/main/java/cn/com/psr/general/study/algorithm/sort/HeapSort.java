package cn.com.psr.general.study.algorithm.sort;

/**
 * 
 * <B> Function : </B> HeapSort <br>
 * <B> Description : </B> 堆排序 <br>
 * <B> Company : </B> <br>
 *
 * @author Pan_Siran <br>
 * @data 2016年11月22日 上午10:05:18 <br>
 * @version v1.0
 *
 */
public class HeapSort {
	
	/*
	 * 基本思想：堆排序是一种树形选择排序，是对直接选择排序的有效改进。 

		堆的定义如下：具有n个元素的序列（h1,h2,...,hn),当且仅当满足（hi>=h2i,hi>=2i+1）或
		
		（hi<=h2i,hi<=2i+1）(i=1,2,...,n/2)时称之为堆。在这里只讨论满足前者条件的堆。由堆的
		
		定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二叉树可以很直观
		
		地表示堆的结构。堆顶为根，其它为左子树、右子树。初始时把要排序的数的序列看作是一
		
		棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。然
		
		后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类
		
		推，直到只有两个节点的堆，并对它们作交换，最后得到有 n个节点的有序序列。从算法
		
		描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所
		
		以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。  
	 * */
	
	
	public void heapSortDemo1(){
		int[] a = {49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51};
		
	}
	
	
}
























